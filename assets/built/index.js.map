{"version":3,"file":"index.js","sources":["../js/directTruncate.js","../js/infiniteScroll.js","../js/menuOpen.js","../js/index.js"],"sourcesContent":["// Direct truncation script to be injected into the page\n(function () {\n    console.log(\"Direct truncation script loaded\");\n\n    function truncateText(element) {\n        // Skip truncation if viewport width is 1000px or less\n        if (window.innerWidth <= 1000) {\n            element.classList.add(\"content-ready\");\n            return;\n        }\n\n        // Get max length from data-truncate attribute\n        const maxLength = parseInt(element.getAttribute(\"data-truncate\"), 10);\n        if (!maxLength) return; // Skip if no max length defined\n\n        const originalText = element.textContent;\n        const dataAttribute = element.classList.contains(\"post-card-title\")\n            ? \"data-full-title\"\n            : \"data-full-excerpt\";\n\n        // Store original text if not already stored\n        if (!element.getAttribute(dataAttribute)) {\n            element.setAttribute(dataAttribute, originalText);\n        }\n\n        // Only truncate if text is longer than max length\n        if (originalText.length > maxLength) {\n            element.textContent = originalText.substring(0, maxLength) + \"...\";\n            console.log(`Text truncated to ${maxLength} characters`);\n        }\n\n        // Always make visible immediately\n        element.classList.add(\"content-ready\");\n    }\n\n    function truncateNow() {\n        console.log(\"Truncating now...\");\n\n        // Process only elements with data-truncate attribute\n        document.querySelectorAll(\"[data-truncate]\").forEach((element) => {\n            // Skip elements that are already processed\n            if (element.classList.contains(\"content-ready\")) return;\n            truncateText(element);\n        });\n    }\n\n    // Function to handle window resize\n    function handleResize() {\n        // If viewport width changes from <= 1000px to > 1000px, reapply truncation\n        if (window.innerWidth > 1000) {\n            // Remove content-ready class to reprocess elements\n            document\n                .querySelectorAll(\"[data-truncate].content-ready\")\n                .forEach((element) => {\n                    element.classList.remove(\"content-ready\");\n                });\n            truncateNow();\n        }\n        // If viewport width changes from > 1000px to <= 1000px, restore original text\n        else {\n            document.querySelectorAll(\"[data-truncate]\").forEach((element) => {\n                const dataAttribute = element.classList.contains(\n                    \"post-card-title\"\n                )\n                    ? \"data-full-title\"\n                    : \"data-full-excerpt\";\n\n                const originalText = element.getAttribute(dataAttribute);\n                if (originalText) {\n                    element.textContent = originalText;\n                }\n\n                element.classList.add(\"content-ready\");\n            });\n        }\n    }\n\n    // Add resize event listener\n    window.addEventListener(\"resize\", handleResize);\n\n    // Run immediately\n    truncateNow();\n\n    // Also run after DOM is fully loaded\n    if (document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", truncateNow);\n    } else {\n        // DOM already loaded, run now\n        truncateNow();\n    }\n\n    // Run again after a delay to ensure all content is loaded\n    setTimeout(truncateNow, 100);\n\n    // Also handle infinite scroll events\n    document.addEventListener(\"infiniteScrollComplete\", () => {\n        console.log(\"Infinite scroll completed, truncating new content\");\n        setTimeout(truncateNow, 100);\n    });\n\n    // Run again if DOM changes (for infinite scroll)\n    const observer = new MutationObserver(function (mutations) {\n        // Check if new elements were added\n        let newElements = false;\n        mutations.forEach((mutation) => {\n            if (mutation.addedNodes.length) {\n                newElements = true;\n            }\n        });\n\n        // Only run truncation if new elements were added\n        if (newElements) {\n            setTimeout(truncateNow, 100);\n        }\n    });\n\n    // Start observing the document\n    if (document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", function () {\n            observer.observe(document.body, { childList: true, subtree: true });\n        });\n    } else {\n        // DOM already loaded, start observing now\n        observer.observe(document.body, { childList: true, subtree: true });\n    }\n})();\n","/*\nThis script continously loads post as the user scrolls the page. It uses the IntersectionObserver API to detect when the last post is in view. When the last post is in view, it fetches the next page and appends the posts to the page. It then checks if there is a next page and if there is, it continues to observe the last post. If there is no next page, it disconnects the observer. \n\nImportantly, for this script to work, it requires that each card have the `post` class and that the card container have the `gh-postfeed` class\n*/\n\nlet link = document.querySelector('link[rel=\"next\"]')?.getAttribute(\"href\");\n\n// Fetch and parse next page\nasync function getNextPage(url) {\n    try {\n        const res = await fetch(url);\n\n        if (!res.ok) {\n            throw new Error(\"Failed to fetch page\");\n        }\n\n        const nextPageHtml = await res.text();\n        const parser = new DOMParser();\n        const parsed = parser.parseFromString(nextPageHtml, \"text/html\");\n        const posts = parsed.querySelectorAll(\".post\");\n        const nextLink = parsed\n            .querySelector('link[rel=\"next\"]')\n            ?.getAttribute(\"href\");\n\n        return { posts, nextLink };\n    } catch (error) {\n        throw new Error(error);\n    }\n}\n\nexport default function infiniteScroll() {\n    if (!link) {\n        return;\n    }\n\n    const options = {\n        // When the last card is within a 150px of the viewport, fetch the next page. This provides a smoother transition between pages\n        rootMargin: \"150px\",\n    };\n\n    const callback = (entries, observer) => {\n        try {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    if (link) {\n                        getNextPage(link).then(({ posts, nextLink }) => {\n                            posts.forEach((post) => {\n                                document\n                                    .querySelector(\".gh-postfeed\")\n                                    .append(post);\n                            });\n\n                            if (nextLink) {\n                                link = nextLink;\n                                observer.observe(\n                                    document.querySelector(\".post:last-of-type\")\n                                );\n                            } else {\n                                observer.disconnect();\n                            }\n\n                            // Dispatch a custom event when new content is loaded\n                            document.dispatchEvent(\n                                new CustomEvent(\"infiniteScrollComplete\")\n                            );\n                        });\n                    }\n                }\n            });\n        } catch (error) {\n            console.log(error);\n        }\n    };\n\n    let observer = new IntersectionObserver(callback, options);\n\n    observer.observe(document.querySelector(\".post:last-of-type\"));\n}\n","// Toggle the menu open and close when on mobile\nexport default function menuOpen() {\n    const burgerButton = document.querySelector('.gh-burger');\n    burgerButton.addEventListener('click', function () {\n        document.body.classList.toggle('gh-head-open');\n    });\n}","// JavaScript files are compiled and minified during the build process to the assets/built folder. See available scripts in the package.json file.\n\n// Import CSS\nimport \"../css/index.css\";\n\n// Import JS - import directTruncate first to ensure it runs as early as possible\nimport \"./directTruncate.js\"; // Direct import, no need for named import since it's self-executing\nimport infiniteScroll from \"./infiniteScroll\";\nimport menuOpen from \"./menuOpen\";\n\n// Call the menu and infinite scroll functions\nmenuOpen();\ninfiniteScroll();\n\n// No need to call truncation function as directTruncate.js is self-executing\n"],"names":["truncateNow","console","log","document","querySelectorAll","forEach","element","classList","contains","window","innerWidth","add","maxLength","parseInt","getAttribute","originalText","textContent","dataAttribute","setAttribute","length","substring","truncateText","addEventListener","remove","readyState","setTimeout","observer","MutationObserver","mutations","newElements","mutation","addedNodes","observe","body","childList","subtree","link","querySelector","toggle","IntersectionObserver","callback","entries","entry","isIntersecting","async","url","res","fetch","ok","Error","nextPageHtml","text","parsed","DOMParser","parseFromString","posts","nextLink","error","getNextPage","then","_ref","post","append","disconnect","dispatchEvent","CustomEvent","rootMargin","infiniteScroll"],"mappings":"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"}